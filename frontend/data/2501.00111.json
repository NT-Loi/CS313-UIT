{
    "arxiv_id": "2501.00111",
    "title": "Binary Jumbled Indexing: Suffix tree histogram",
    "authors": [
        {
            "name": "L Cunha",
            "citations_all": 194,
            "citations_recent": 143,
            "h_index_all": 8,
            "h_index_recent": 7,
            "i10_index_all": 6,
            "i10_index_recent": 3
        },
        {
            "name": "M Medina",
            "citations_all": null,
            "citations_recent": null,
            "h_index_all": null,
            "h_index_recent": null,
            "i10_index_all": null,
            "i10_index_recent": null
        }
    ],
    "abstract": "Given a binary string $\\omega$ over the alphabet $\\{0, 1\\}$, a vector $(a, b)$ is a Parikh vector if and only if a factor of $\\omega$ contains exactly $a$ occurrences of $0$ and $b$ occurrences of $1$. Answering whether a vector is a Parikh vector of $\\omega$ is known as the Binary Jumbled Indexing Problem (BJPMP) or the Histogram Indexing Problem. Most solutions to this problem rely on an $O(n)$ word-space index to answer queries in constant time, encoding the Parikh set of $\\omega$, i.e., all its Parikh vectors. Cunha et al. (Combinatorial Pattern Matching, 2017) introduced an algorithm (JBM2017), which computes the index table in $O(n+\\rho^2)$ time, where $\\rho$ is the number of runs of identical digits in $\\omega$, leading to $O(n^2)$ in the worst case. We prove that the average number of runs $\\rho$ is $n/4$, confirming the quadratic behavior also in the average-case. We propose a new algorithm, SFTree, which uses a suffix tree to remove duplicate substrings. Although SFTree also has an average-case complexity of $\\Theta(n^2)$ due to the fundamental reliance on run boundaries, it achieves practical improvements by minimizing memory access overhead through vectorization. The suffix tree further allows distinct substrings to be processed efficiently, reducing the effective cost of memory access. As a result, while both algorithms exhibit similar theoretical growth, SFTree significantly outperforms others in practice. Our analysis highlights both the theoretical and practical benefits of the SFTree approach, with potential extensions to other applications of suffix trees.",
    "published_date": "2024-12-30T00:00:00",
    "last_revised_date": "2024-12-30T00:00:00",
    "num_revisions": 0,
    "pdf_url": "https://arxiv.org/pdf/2501.00111.pdf",
    "primary_category": "Data Structures and Algorithms (cs.DS)",
    "categories": [
        "Data Structures and Algorithms (cs.DS)"
    ],
    "keywords": [
        "Binary jumbled pattern matching Jumbled indexing Histogram indexing Parikh set Parikh vectors Suffix tree String indexing Prefix normal form"
    ],
    "num_pages": 17,
    "github_stars": null,
    "upvote": 0,
    "citing_models": 0,
    "citing_datasets": 0,
    "citing_spaces": 0,
    "citing_collections": 0,
    "citations_by_year": {},
    "citationCount": 0,
    "venue": {
        "name": "arXiv.org",
        "type": null
    },
    "citations": [],
    "referenceCount": 0,
    "references": [],
    "influentialCitationCount": 0,
    "embedding": null
}